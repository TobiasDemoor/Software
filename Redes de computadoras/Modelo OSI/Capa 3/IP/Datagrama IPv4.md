Un datagrama IPv4 ([[IP]] versión 4) consiste en dos partes: el encabezado y el cuerpo o carga útil. El encabezado tiene una parte fija de 20 bytes y una parte opcional de longitud variable. Los bits se transmiten en orden de izquierda a derecha y de arriba hacia abajo, comenzando por el bit de mayor orden del campo *Versión* (éste es un orden de bytes de red *big endian*. En las máquinas *little endian*, como las computadoras Intel x86, se requiere una conversión por software tanto para la transmisión como para la recepción). En retrospectiva, el formato *little endian* hubiera sido una mejor opción, pero al momento de diseñar IP nadie sabía que llegaría a dominar la computación

![[encabezado_IPv4.png]]

El campo *Versión* lleva el registro de la versión del protocolo al que pertenece el datagrama. Al incluir la versión al inicio de cada datagrama, es posible tener una transición entre versiones a través de un largo periodo de tiempo. De hecho, IPv6 (la siguiente versión de IP) se definió hace más de una década y apenas se está empezando a implementar.

Dado que la longitud del encabezado no es constante, se incluye un campo en el encabezado (*IHL*) para indicar su longitud en palabras de 32 bits. El valor mínimo es de 5, cifra que se aplica cuando no hay opciones. El valor máximo de este campo de 4 bits es 15, lo que limita el encabezado a 60 bytes y por lo tanto, el campo *Opciones* a 40 bytes. Para algunas opciones, por ejemplo una que registre la ruta que ha seguido un paquete, 40 bytes es muy poco, lo que hace inútiles estas opciones.

El campo de *Servicio diferenciado* es uno de los pocos campos que ha cambiado su significado (ligeramente) con el transcurso de los años. En un principio el nombre de este campo era *Tipo de servicio*. Su propósito era, y aún es, distinguir entre las diferentes clases de servicios. Son posibles varias combinaciones de confiabilidad y velocidad. Para voz digitalizada, la entrega rápida le gana a la entrega precisa. Para la transferencia de archivos, es más importante la transmisión libre de errores que la transmisión rápida. El campo *Tipo de servicio* contaba con 3 bits para indicar la prioridad y 3 bits para indicar si a un host le preocupaba más el retardo, la velocidad de transmisión real o la confiabilidad. Sin embargo, nadie sabía realmente qué hacer con estos bits en los enrutadores, por lo que se quedaron sin uso durante muchos años. Cuando se diseñaron los servicios diferenciados, la IETF tiró la toalla y reutilizó este campo. Ahora, los 6 bits superiores se utilizan para marcar el paquete con su clase de servicio (servicios expedito y asegurado). Los 2 bits inferiores se utilizan para transportar información sobre la notificación de congestión; por ejemplo, si el paquete ha experimentado congestión o no.

El campo *Longitud total* incluye todo en el datagrama: tanto el encabezado como los datos. La longitud máxima es de 65.535 bytes. En la actualidad este límite es tolerable, pero con las redes futuras tal vez se requieran datagramas más grandes.

El campo *Identificación* es necesario para que el host de destino determine a qué paquete pertenece un fragmento recién llegado. Todos los fragmentos de un paquete contienen el mismo valor de Identificación.

Después vienen dos campos de 1 bit relacionados con la fragmentación. *DF* (Don’t Fragment), es una orden para que los enrutadores no fragmenten el paquete. En un principio estaban destinados para soportar a los hosts incapaces de reunir las piezas otra vez. Ahora se utiliza como parte del proceso para descubrir la MTU de la ruta: el paquete más grande que puede viajar a través de una ruta sin necesidad de fragmentarse. Al marcar el datagrama con el bit *DF*, el emisor sabe que llegará en una pieza o recibirá de vuelta un mensaje de error.

Todos los fragmentos excepto el último tienen establecido el bit *MF* (More Fragments), que es necesario para saber cuándo han llegado todos los fragmentos de un datagrama.

El *Desplazamiento del fragmento* indica a qué parte del paquete actual pertenece este fragmento. Todos los fragmentos excepto el último del datagrama deben ser un múltiplo de 8 bytes, que es la unidad de fragmentos elemental. Dado que se proporcionan 13 bits, puede haber un máximo de 8192 fragmentos por datagrama, para soportar una longitud máxima de paquete de hasta el límite del campo *Longitud total*. En conjunto, los campos *Identificación*, *MF* y *Desplazamiento del fragmento* se utilizan para implementar la **fragmentación**.

El campo *TtL* (Time to Live) es un contador que se utiliza para limitar el tiempo de vida de un paquete. En un principio se suponía que iba a contar el tiempo en segundos, lo cual permitía un periodo de vida máximo de 255 seg. Hay que decrementarlo en cada salto y se supone que se decrementa muchas veces cuando un paquete se pone en cola durante un largo tiempo en un enrutador. En la práctica, simplemente cuenta los saltos. Cuando el contador llega a cero, el paquete se descarta y se envía de regreso un paquete de aviso al host de origen. Esta característica evita que los paquetes anden vagando eternamente, algo que de otra manera podría ocurrir si se llegaran a corromper las tablas de enrutamiento.

Una vez que la capa de red ha ensamblado un paquete completo, necesita saber qué hacer con él. El campo *Protocolo* le indica a cuál proceso de transporte debe entregar el paquete. [[TCP]] es una posibilidad, pero también están [[UDP]] y otros más. La numeración de los protocolos es global en toda la Internet. Anteriormente los protocolos y otros números asignados se listaban en el [[RFC]] 1700, pero en la actualidad están contenidos en una base de datos en línea localizada en www.iana.org.

Puesto que el encabezado transporta información vital, como las direcciones, estima su propia suma de verificación por protección, la *Suma de verificación del encabezado*. El algoritmo suma todas las medias palabras de 16 bits del encabezado a medida que vayan llegando, mediante el uso de la aritmética de complemento a uno, y después obtiene el complemento a uno del resultado. Para los fines de este algoritmo, se supone que la *Suma de verificación del encabezado* es cero al momento de la llegada. Dicha suma de verificación es útil para detectar errores mientras el paquete viaja por la red. Tenga en cuenta que se debe recalcular en cada salto, ya que por lo menos hay un campo que siempre cambia (el campo *TtL*), aunque se pueden usar trucos para agilizar ese cálculo.

Los campos *Dirección de origen* y *Dirección de destino* indican la [[Direcciones IP|dirección IP]] de las interfaces de red de la fuente y del destino.

El campo *Opciones* se diseñó para proporcionar un recurso que permitiera que las versiones subsiguientes del protocolo incluyeran información que no estuviera presente en el diseño original, para que los experimentadores puedan probar ideas nuevas y evitar la asignación de bits de encabezado a la información que se necesite muy poco. Las opciones son de longitud variable. Cada una empieza con un código de 1 byte que identifica la opción. Algunas opciones van seguidas de un campo de longitud de la opción de 1 byte, y luego de uno o más bytes de datos. El campo Opciones se rellena para completar múltiplos de 4 bytes. En un principio se definieron cinco opciones.

| Opción                                 | Descripción                                                           |
| -------------------------------------- | --------------------------------------------------------------------- |
| Seguridad.                             | Especifica qué tan secreto es el datagrama.                           |
| Enrutamiento estricto desde el origen. | Proporciona la ruta completa a seguir.                                |
| Enrutamiento libre desde el origen.    | Proporciona una lista de enrutadores que no se deben omitir.          |
| Registrar ruta.                        | Hace que cada enrutador adjunte su dirección IP.                      |
| Estampa de tiempo.                     | Hace que cada enrutador adjunte su dirección y su etiqueta de tiempo. |

Hoy en día se han dejado de usar las opciones IP. La mayoría de los enrutadores las ignoran o no las procesan en forma eficiente, haciéndolas a un lado como un caso poco común. Es decir, sólo cuentan con soporte parcial y se usan muy raras veces.